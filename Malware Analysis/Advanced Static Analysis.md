<br>

# Introduction
-----
<span style="color:#047c3a">Advanced static malware analysis</span> stands for tearing down of a malware into it's most basic (Assembly) form using <span style="color:#047c3a">disassemblers</span> and <span style="color:#047c3a">decompilers</span>.
We will reverse engineer the binaries and recreate it's code as close as possible to it's source code.
<br>

# Assembly Basics
------
<span style="color:#047c3a">Assembly language</span> is a low-level programming language for a computer or other programmable device specific to a particular computer architecture in contrast to most high-level programming languages, which are generally portable across multiple systems. Assembly language is converted into executable machine code by a utility program referred to as an assembler like NASM, MASM, etc.

For more details, refer to <span style="color:#00b0f0">assembly books in Book-collection section</span>.
<br>

# Decompiling And Disassembling Malware
-------
Tools used - <span style="color:#ffff00">cutter</span>

Open cutter and select the executable-

![[Pasted image 20230728000944.png]]
Now click on open. A new window pops up .
![[Pasted image 20230728001102.png]]
No need to do anything now.Just click on ok.
After some time we are greeted with a screen showing some familiar stuff about the malware such as format,hashes,libraries,etc.
![[Pasted image 20230728001252.png]]
We have some options on the bottom for previous static analysis methods such as -
![[Pasted image 20230728001427.png]]
Clicking on Disassembly, we find a list of functions called upon by the malware on the left and the assembly code on the right.

![[Pasted image 20230728002147.png]]

After scrolling down on the left sidebar, we stumble upon the <span style="color:#7030a0">main</span> function of the program.
![[Pasted image 20230728002422.png]]

We also see the graph tab on the bottom. It gives out a graph form of the malware program flow.
![[Pasted image 20230728002836.png]]
![[Pasted image 20230728002853.png]]

As we look closely on the graph we can see the program flow of the malware -
![[Pasted image 20230728003224.png]]
It creates a file and reaches out for `http:__ssl_6582datamanager.helpdeskbros.local_favicon.ico`.
Now as per the reception of the file, it tells the <span style="color:#047c3a">eax</span> register what to do next.

If file is returned, then if executes the below-
![[Pasted image 20230728003508.png]]
which is the <span style="color:#047c3a">assimilation of the favicon.ico and the created exe file</span> which in turn starts a bind shell on port 5555.

If <span style="color:#047c3a">web is unreachable, it deletes itself and the created exe file</span> as shown below.
![[Pasted image 20230728003807.png]]

The <span style="color:#047c3a">Decompiler</span> option takes all the assembly information and tries to recreate the source as close to the source code as possible.
![[Pasted image 20230728004116.png]]
<br>

# More on x86 cpu architecture
-----
For a binary to execute in x86 architecture, there are three things that should be taken into account -

1. CPU instructions
2. Memory registers
3. Stack

x86 instruction is written in <span style="color:#047c3a">little endian</span> format i.e the instruction comes before the destination and the source.
For example, in -

		MOV R1,R0

`MOV` will be executed first . Then data from `R0` is transferred to `R1`.

For jumping and logical branching , `JMP` instruction is used.

Stack is a special place in memory which stores data in a sequential order i.e the order in which they are to be executed. Stack grows downward i.e new data is added to the stack at lower addresses.

`PUSH` is used to add data to stack.
`POP` is used to remove lowest data from stack.

`Call` instruction is used to call subroutines from the main method.

`Ret` instruction is used to return data from the subroutine to the main function.

##### Registers-
`EAX` is the accumulator register.
`EDX` is the data register.
`EBX` is the base register.
`ESP` is the extended stack pointer.
`EBP` is the extended base pointer.
`EIP` is the extended instruction pointer.

<span style="color:#ffff00">Below is a brief overview of above concepts -</span>

### Memory Layout

Memory is simply an array of bytes, each byte having its own address. When a program is executed, the operating system allocates a chunk of memory to the program. That memory (called _address space_) is divided into different segments as shown below:

![Memory layout of a process](https://miro.medium.com/v2/resize:fit:788/1*oLatmtP-JHDF8SSpoX2Nxg.gif)

Memory layout of a process

- The **text** section stores the program executable. When you compile a C program, the compiler converts your code to `0`s and `1`s, which represent instructions that the CPU will execute. Those `0`s and `1`s are going to be loaded into this _text_ section when you run the program.
- The **data** section stores initialized data (i.e. global variables that have been initialized).
- The **bss** section stores uninitialized data (i.e. global variables that have not been initialized). In case you’re curious, it stands for [_Block Started by Symbol_](https://en.wikipedia.org/wiki/.bss), named after an ancient assembler operator.
- The **heap** section are memory that you can dynamically reserve from calling _malloc_. The heap typically grows upwards, which means it grows toward larger memory addresses.
- The **stack** section are memory that your [functions](https://youtu.be/aCPkszeKRa4) and the [local variables](https://youtu.be/EXSijgdztCg?t=4700) inside your functions live. It is divided into _stack frames_, which grow downwards (i.e. grow toward lower memory addresses).

Keep this memory layout in mind. We will come back to it later when we start programming in assembly.

### Registers

It turns out that modern computers require more than a physical memory to operate. Inside the CPU, there exists a small piece of memory called _registers_. Registers are extremely fast, because it can be directly accessed by the CPU. Modern x86–64 processors have 16 general-purpose 64-bit registers, whose names can be overwhelming to understand at first. So I’ll provide some historical context to help you understand them better. But first, the overall layout of the x86–64 registers:

![Layout of 64-bit registers](https://miro.medium.com/v2/resize:fit:1078/1*4ipwUzIWd4eqUvcEmZ5tMQ.png)

Layout of x86–64 registers

Okay. Ignore all the descriptions on the right. In fact, ignore the entire image above. Don’t try to understand it right now. I put it purely for reference. We can come back to this later.

### [Backstory](http://learn-assembly.blogspot.com/2009/04/general-registers-ax-bx-cx-and-dx.html)

##### 8-bit registers

Long long time ago, in the age of the [_Intel 8080_](https://en.wikipedia.org/wiki/Intel_8080), registers are only 8 bits in size. They are simply named _A_, _B_, _C_, _D_, _E_, _H_, and _L_ registers.

- The **A register**, in particular, was used as a primary [_accumulator_](https://en.wikipedia.org/wiki/Accumulator_(computing)). It accumulates (as you’ll see when we get to the actual assembly part) the result of most operations.
- The **B register** stands for the _base_ register, which historically was used to store the [_base address_](https://retrocomputing.stackexchange.com/questions/7627/is-bx-the-base-address-register-and-if-so-why) of something we want to reference in memory (think arrays in C, where the reference address would be the address of the first element).
- The **C register** was the _counter_ register, used to store counts just like the modern counter variables.
- The **D register** stands for the _data_ register. It was used to store the data of most I/O operations.

![Intel 8080 (8-bit) registers](https://miro.medium.com/v2/resize:fit:1313/1*uF5wbetOgWjMu5lYV1Gw9w.jpeg)

Picture from [https://en.wikipedia.org/wiki/Intel_8080](https://en.wikipedia.org/wiki/Intel_8080)

In addition to general-purpose registers, we have [_status register_](https://en.wikipedia.org/wiki/Status_register), or _flag bits_, which are a series of bits that represent the status of certain operations. For example,

- the **sign bit (S)** will be set to `1` if the result of the previous operation is negative, and `0` if the result is non-negative.
- The **zero bit (Z)** will be set to `1` if the result of the previous operation is zero, and `0` if the result is non-zero, so on, so forth.

And then we have some special registers, like the **stack pointer (SP)**, and the **instruction pointer (IP)** or the program counter, which we’ll get back to in a moment.

#### 16-bit registers

Fast forward a few years later, the [_Intel 8086_](https://en.wikipedia.org/wiki/Intel_8086) came out. The architects of the 8086 added a slew of other registers, and made them 16-bit in size. Among all the changes, the original _A_, _B_, _C_, and _D_ registers had a slight modification to their names. Since the registers are 16 bits now, we can divide the original registers up into two 8-bit registers like these:

![16-bit registers](https://miro.medium.com/v2/resize:fit:1313/1*hcw0-XNds2MWqKBTj6_pHQ.jpeg)

The **AH** and **AL** registers are called the _“high byte”_ and the _“low byte”_ respectively. Each of them are 8-bit (a byte) in size, but are [paired up](https://stackoverflow.com/questions/2545192/what-does-x-mean-in-eax-ebx-ecx-in-assembly) to form the 16-bit **AX** register (_X_ in this case just stands for _pair_).

For example, if I have `0100 1101` stored in _AX_,

- _AH_ would store `0100`,
- _AL_ would store `1101`,
- _AX_ would represent the entire `0100 1101`.

Same goes for the _BX_, _CX_, and _DX_ registers. At this point, I should introduce two new terminologies. You are going to hear these terms a lot more often now: a **byte**, which just means _8 bits_; and a **word**, which means _16 bits_.

The 8086 also contains a couple of new _word_ registers and flag bits, among them:

- the **SI (Source Index)** register, used as a pointer to a source in stream operations
- the **DI (Destination Index)** register, used as a pointer to a destination in stream operations
- the **BP (Base Pointer)** register, used as a pointer to the base of a stack frame (we’ll see examples of this)
- the **SP (Stack Pointer)** register — okay, you have seen this one before, and it’s used as a pointer to the current position in the stack (we’ll also see examples of this soon)

Here is a picture summary of what we learned so far.

![Intel 8086 (16-bit) registers](https://miro.medium.com/v2/resize:fit:1313/1*pnHI09kcqlX6HUXKp1P8jA.jpeg)

Picture from [https://en.wikipedia.org/wiki/Intel_8086](https://en.wikipedia.org/wiki/Intel_8086)

Don’t worry about the _segment registers_ yet. We’ll probably never touch them in your class.

If you’re feeling pretty overwhelmed at this point, stop reading. Go take a break. Don’t look at the diagram above, but look at the diagram below instead, because things are about to get interesting.

#### 32-bit registers

![32-bit registers](https://miro.medium.com/v2/resize:fit:1313/1*kkrG2L61YUbGLxwv5UcoPQ.png)

Picture from [https://www.cs.virginia.edu/~evans/cs216/guides/x86.html](https://www.cs.virginia.edu/~evans/cs216/guides/x86.html)

Modern computers nowadays work on at least 32-bit (**long** or **dword**, short for _double word_) registers. This time, same concept as before, **EAX** (stands for _extended AX_) refer to the entire 32-bit value. If you want to access the lower _word_ value of EAX, you can still use AX. Sadly, you won’t be able to access the higher _word_ value of EAX this time.

To give an example, suppose EAX stores `1100 0100 1110 0010`,

- _AL_ would be `0010`,
- _AH_ would be `1110`,
- _AX_ would be `1110 0010`,
- _EAX_ would be `1100 0100 1110 0010`.

It is important that you are familiar with all the registers you have learned so far, so study the diagram above!

#### 64-bit registers

Here’s the fun part: if I show you the image I told you to skip in the beginning, it kinda starts to make sense.

![64-bit registers](https://miro.medium.com/v2/resize:fit:834/1*I8_t0-cmbo5cHPK59aYhdA.png)

x86–64 registers

Yes, that’s how 64-bit (**qword**, short for _quad word_) registers look like. You’ll notice that you can now access the entire 64-bit value with **RAX** (that _R_ just stands for _register_, I guess they ran out of names…). EAX, AX, AH and AL are still there to maintain backward compatibility. Same goes for all the other registers.

You also have additional general-purpose registers, _R8_ to _R15_, which can be used to store anything you like. In fact, this whole time, you can store anything you like in any register — like you don’t need to store counter values in RCX, because RCX is just a regular ol’ piece of memory!
<br>

# Assembly And Windows API
------
Going back to cutter and dropper malware sample -

![[Pasted image 20230729000104.png]]

Two arguments - <span style="color:#047c3a">argc</span> and <span style="color:#047c3a">argv</span> are passed implicitly into the main function.
<span style="color:#047c3a">argc</span> takes in the source and destination .
<span style="color:#047c3a">argv</span> takes in the strings themselves which are passed along to the malware.

![[Pasted image 20230729000444.png]]
We see that some variables are declared at the start. As we dont know anything about them, they are ignored for now.

![[Pasted image 20230729000619.png]]
The base pointer is pushed onto the stack . This is important because if we don't have the pointer to the main program before executing subroutines, we can't return back to the main function. Thus leading to halt the program.

![[Pasted image 20230729001057.png]]
This is used to setup a function call.

![[Pasted image 20230729001233.png]]
Here a call to the API <span style="color:#047c3a">InternetOpenW</span> is being made. It requires a header which is -
<span style="color:#047c3a">Mozilla_5.0</span>. Also the zeros are arguments which are passed onto the API. It is consistent with the documentation-->
```
HINTERNET InternetOpenA(
  [in] LPCSTR lpszAgent,
  [in] DWORD  dwAccessType,
  [in] LPCSTR lpszProxy,
  [in] LPCSTR lpszProxyBypass,
  [in] DWORD  dwFlags
);
```

After that there is a call to a function -
![[Pasted image 20230729001800.png]]
Clicking on it, we get a whole graph of that function-->
![[Pasted image 20230729001859.png]]
Returning back to the main program, there is another call to an API - <span style="color:#047c3a">URLDownloadToFile</span>.
![[Pasted image 20230729002043.png]]

```
HRESULT URLDownloadToFile(
             LPUNKNOWN            pCaller,
             LPCTSTR              szURL,
             LPCTSTR              szFileName,
  _Reserved_ DWORD                dwReserved,
             LPBINDSTATUSCALLBACK lpfnCB
);
```
The parameters passed onto it is also consistent with the official documentation.

This concludes <span style="color:#ffff00">advanced static analysis</span>.
